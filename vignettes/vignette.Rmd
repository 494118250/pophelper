---
title: "Pophelper 2.0.0"
output: 
  html_document: 
    code_folding: "hide"
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: true
    number_sections: true
  highlight: tango 
  theme: flatly
vignette: >
  %\VignetteIndexEntry{Pophelper tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

__Roy M Francis__ | 22-Dec-2016

```{r,echo=FALSE,message=FALSE,results='hide',warning=FALSE,eval=TRUE}
options(rpubs.upload.method="internal")
knitr::opts_chunk$set(collapse=TRUE)
#source("D:/Data/Dropbox/Rwork/pophelperRpackage/pophelper/R/pophelper.R")
library(pophelper)
```

# Introduction  

This vignette/tutorial aims to demonstrate the use of R package `pophelper`. This package contains functions that are useful for processing output results from programs used in the analysis of population structure such as ADMIXTURE^1^, FASTSTRUCTURE^6^, STRUCTURE^5^, TESS^3^ and any q-matrix output as a numeric tabular delimited file.

Softwares such as ADMIXTURE, FASTSTRUCTURE, STRUCTURE and TESS are popular programs used to discriminate populations, to determine population structure and to reveal the genetic composition of individuals using molecular markers. These programs generally use allelic frequency information to assign individuals to a pre-defined number of populations (*K*). The assignment is usually run for a range of *K* such as from *K*=2 to *K*=10. Multiple repeats are also usually carried out for each *K*. Each output file for each repeat of *K* showing the assignment probabilities of all individuals is referred to as the run file, cluster file or q-matrix file. `pophelper` has a set of functions that include tabulating, summarising and plotting that can be applied to these run files. 

This vignette covers the use of all important functions in the `pophelper` package. The demonstration is ordered in the manner of a typical workflow. Input and output codes are printed in a font different from body text like `this`.  

----

# Installation  

The first step is to install the `pophelper` library. The source code is available from [GitHub](https://github.com/royfrancis/pophelper). You need to have R (>= 3.3.0) installed on your system. Then, install the `devtools` package. 

```{r,echo=TRUE,eval=FALSE,results='hide'}
# Install devtools package
install.packages('devtools',dependencies=T)
library(devtools)
```

It is best to first install the dependency packages.  

```{r,echo=TRUE,eval=FALSE,results='hide'}
install.packages(c("Cairo","ggplot2","gridExtra","gtable","tidyr"),dependencies=T)
```

Then, install `pophelper` package from `github` using the function `install_github()` from `devtools` package.  

```{r,echo=TRUE,eval=FALSE,results='hide'}
# Install the current version of pophelper
install_github('royfrancis/pophelper')
```

Note that `ggplot2` version must be 2.2.0 or higher. And the `pophelper` package can be installed as previously mentioned. Once the package is installed, the package is loaded as shown below.

```{r,echo=TRUE,eval=FALSE,results='hide'}
# load library
library(pophelper)

# check version
packageDescription("pophelper", fields="Version")
```

The next step is to set the working directory. The working directory is a folder that usually contains the run files of interest so as to allow R to access it. The working directory must have read-write-execute permissions. Functions may produce outputs such as text files or images which will be exported to the working directory. The working directory can be set by running the command below using a path or by selecting the folder interactively in the popup window.

```{r,echo=TRUE,eval=FALSE,results='hide'}
setwd("path")
setwd(choose.dir())
```

Standard help and documentation for all functions are obtained using `?`.

```{r,echo=TRUE,eval=FALSE,results='hide'}
?tabulateQ
?summariseQ
?collectRunsTess
#If using RStudio, press tab inside function to see arguments.
#readQ(<press tab>)
```

For functions where one or more files need to be selected, the selection can be performed interactively. Windows users can use `choose.files(multi=T)` for multi-selection or `file.choose()` for single selection. Mac users can use `file.choose()` for single selection and `tk_choose.files()` from `tcltk` package for multiple selection.

----

# Functions & Overview  
All user functions in the `pophelper` package are listed below.  
 
```{r, eval=FALSE,echo=TRUE}
readQ()                   # convert q-matrix run files to qlist
tabulateQ()               # tabulate a qlist
summariseQ()              # summarise an output from tabulateQ()
clumppExport()            # generate CLUMPP input/output files
collectClumppOutput()     # collect CLUMPP output into a common directory
plotQ()                   # create barplots from qlist
PlotQMultiline()          # create multi-line barplots from qlist
distructExport()          # export files for DISTRUCT from qlist

evannoMethodStructure()   # perform the Evanno method for STRUCTURE data
collectRunsTess()         # collect TESS output from multiple directories into one

analyseQ()                # wrapper function to quickly tabulate, summarise, 
                          # perform evanno method, clumpp output and generate
                          # barplots from filenames/paths.

# Deprecated Functions
# functions from previous version of pophelper absent in current version
tabulateRunsStructure()   # renamed to tabulateQ
tabulateRunsTess()        # renamed to tabulateQ
tabulateRunsMatrix()      # renamed to tabulateQ

summariseRunsStructure()  # renamed to summariseQ
summariseRunsTess()       # renamed to summariseQ
summariseRunsMatrix()     # renamed to summariseQ

runsToDfStructure()       # renamed to readQ
runsToDfTess()            # renamed to readQ
runsToDfMatrix()          # renamed to readQ

clumppExportStructure()   # renamed to clumppExport
clumppExportTess()        # renamed to clumppExport
clumppExportMatrix()      # renamed to clumppExport

plotRuns()                # renamed to plotQ
plotMultiline()           # renamed to plotQMultiline
analyseRuns()             # renamed to analyseQ

plotRunsInterpolate()     # renamed to plotQInterpolate
                          # moved to package pophelperSpatial
plotRunsSpatial()         # renamed to plotQSpatial
                          # moved to package pophelperSpatial
```

----

# Input files  
Generally speaking, there are four input file formats that can be defined. All are text formats. These are STRUCTURE run files, TESS run files (-TR files in folders), BASIC (simple delimited files) or a CLUMPP associated file. 

STRUCTURE and TESS run files have specific format as shown below in __Fig. 1__. BASIC files are numeric delimited tabular file like ADMIXTURE run files and FASTSTRUCTURE meanQ files. They can also be a generic numeric tabular tab, space or comma-delimited files without headers. CLUMPP associated files are COMBINED, ALIGNED or MERGED files for use with CLUMPP. The COMBINED file is generated using the function `clumppExport()`. The ALIGNED and MERGED files are generated by CLUMPP. A sample CLUMPP format is shown in __Fig. 2__.

The `readQ()` function in `pophelper` is used to read in these different input file types and convert them into an R list object. This list is referred to as a `qlist`. For those familiar with R, a `qlist` is just a regular list datatype in R. Each table/file is converted to a data.frame object which is stored in a list. Multiple runs would be a list of lists.

A schematic data structure of a two run qlist would look like below:

```{r, eval=FALSE}
$list
+--$list
+  +--$data.frame
+--$list
   +--$data.frame
```

An example is shown below

```{r, eval=FALSE,echo=TRUE}
sfiles <- list.files(path=system.file("files/structure",package="pophelper"),full.names=T)
sf <- readQ(files=sfiles[1:2])
str(sf)
```

`qlist`s can also be create manually or generated in R just like any other list without using the `readQ` function in `pophelper`. But, note that `evannoMethodStructure()` needs the attributes associated with the data.frame. Other functions currently do not use the attributes.

Here is a toy qlist object

```{r, eval=FALSE,echo=TRUE}
# create two data frames
df1 <- data.frame(Cluster1=c(0.2,0.4,0.6,0.2),Cluster2=c(0.8,0.6,0.4,0.8))
df2 <- data.frame(Cluster1=c(0.3,0.1,0.5,0.6),Cluster2=c(0.7,0.9,0.5,0.4))

# one-element qlist
q1 <- list("sample1"=df1)
str(q1)

# two-element qlist
q2 <- list("sample1"=df1,"sample2"=df2)
str(q2)
```

![input-preview](input-preview.png)  
__Fig. 1:__ *A preview of the input files. STRUCTURE file (Left), TESS file (centre) and BASIC file (right).*  

COMBINED, ALIGNED and MERGED files used with CLUMPP are referred to as CLUMPP files. They can also be used for plotting.

![clumpp-format](clumpp-format.png)  
__Fig. 2:__ *A preview of the CLUMPP format file.* 

----

# Workflow  

In this section, we will look at how these functions are used, their syntax and typical order of workflow. The workflow is similar for all input filetypes. A few specific functions are specific to certain filetypes.

The `pophelper` library must be loaded and a working directory must be set.

```{r, eval=FALSE,echo=TRUE}
library(pophelper)
setwd("path-to-wd")
```

![Workflow](workflow.png)  
__Fig. 3:__ *Workflow for all filetypes. Files/objects are indicated in black text and functions are indicated in blue. External executables are indicated in green. For CLUMPP and DISTRUCT results, the executables must be run manually or set argument `useexe=T` for automatic execution. The `analyseQ()` function is a wrapper function which can be used to run several functions together. This is indicated by the orange path. Functions indicated with superscripts 1 and 2 are only applicable to specific filetypes. `collectRunsTess()` is used to consolidate and rename TESS runs. evannoMethodStructure() is used to perform the Evanno method for STRUCTURE runs.*

## collectRunsTess  

This function is applicable only to TESS runs. Unlike STRUCTURE runs which are exported into a single directory, TESS output files are exported into separate directories by run. This means that one needs to go into individual folders to obtain the run file. The function `collectRunsTess()` collects TESS cluster files from individual run folders into one new folder and rename each runfile by the folder name. Set working directory first and run basic usage.

```{r,echo=FALSE, eval=FALSE, results='hide'}
# basic usage
collectRunsTess(runsdir="D://Data/Dropbox/Rwork/pophelperRpackage/tessoriginal")
```

```{r,echo=TRUE, eval=FALSE}
# basic usage
collectRunsTess(runsdir="path-to-tess-runs-root-dir")

# another usage
path <- "path-to-tess-runs-root-dir"
collectRunsTess(runsdir=path)

# another usage
collectRunsTess(runsdir=choose.dir())
```

Within each TESS run folder, the function searches for filename ending with 'TR.txt' as the cluster file. This file is copied to the new folder and renamed with the name of the respective run directory. Therefore, DO NOT manually rename original TESS run files or directories.

## readQ 

All input filetypes (STRUCTURE, TESS, BASIC, CLUMPP) can be converted to a qlist using the function `readQ()`. The argument `filetype` is used to specify the input filetype. By default, `filetype` is set to 'auto' which automatically detects input filetype. If this does not work, `filetype` can also be manually set.

```{r, eval=FALSE,echo=TRUE}
readQ(filetype="auto")      # automatically detects input filetype
readQ(filetype="structure") # Convert STRUCTURE run files to qlist
readQ(filetype="tess")      # Convert TESS run files to qlist
readQ(filetype="basic")     # Convert delimited numeric text files to qlist
readQ(filetype="clumpp")    # Convert CLUMPP format files to qlist
```

For this tutorial, we will use the sample files accompanied with this package.

```{r, echo=TRUE, eval=TRUE, results='hide'}
# STRUCTURE files
sfiles <- list.files(path=system.file("files/structure",package="pophelper"),full.names=T)
# basic usage
slist <- readQ(files=sfiles)
readQ(files=sfiles,filetype="structure")
# select files interactively
# readQ(files=choose.files(multi=TRUE))
# check class of ouput
class(slist)
# view head of first converted file
head(slist[[1]])

# TESS files
tfiles <- list.files(path=system.file("files/tess",package="pophelper"),full.names=T)
tlist <- readQ(files=tfiles)
# select files interactively
# readQ(files=choose.files(multi=TRUE))

# use ADMIXTURE files
afiles<- list.files(path=system.file("files/admixture",package="pophelper"),full.names=T)
alist <- readQ(files=afiles)

# use FASTSTRUCTURE files
ffiles <- list.files(path=system.file("files/faststructure",package="pophelper"),full.names=T)
flist <- readQ(files=ffiles)

# use space-delimited text files
msfiles <- list.files(path=system.file("files/basic/space",package="pophelper"),full.names=T)
mslist <- readQ(files=msfiles)

# use tab-delimited text files
mtfiles <- list.files(path=system.file("files/basic/tab",package="pophelper"),full.names=T)
mtlist <- readQ(files=mtfiles)

# use comma-separated text files
mcfiles <- list.files(path=system.file("files/basic/comma",package="pophelper"),full.names=T)
mclist <- readQ(files=mcfiles)
```

Each run is converted to dataframes of assignment probabilities of all individuals in *K* clusters denoted as Cluster1, Cluster 2 etc. The dataframes are placed in named lists. The names are obtained from filenames. Filename suffixes such as .txt, .csv, .tsv and .meanQ are dropped. In case filenames are missing or not available, lists are named sample1, sample2 etc.

Each data.frame has some associated metadata, which is especially important for STRUCTURE runs. When reading in STRUCTURE runs using `readQ()`, metadata such as number of loci, number of burnins, reps, estimated log probability etc., which are required for the Evanno method are stored with each data.frame as attributes. The attributes of the run can be accessed as below.

```{r,echo=TRUE, eval=FALSE, results='hide'}
# qlist attributes
attributes(slist)
# dataframe attributes
attributes(slist[[1]])
```

If individual labels are present in the STRUCTURE file, they can be imported as rownames by setting `indlabfromfile=T`. Space in labels may be replaced by underscore. Incorrect parsing with internal population flags may introduce underscores. If duplicate labels are found, the labels are not imported. This is applicable only for STRUCTURE files.

```{r,echo=TRUE, eval=FALSE, results='hide'}
# include individual names from STRUCTURE file as row names
readQ(files=sfiles,indlabfromfile=T)

# read only one file
readQ(files=sfiles[1],indlabfromfile=T)
```

CLUMPP files (COMBINED, ALIGNED and MERGED) files can also be converted to a qlist using `readQ`.

```{r,echo=TRUE, eval=FALSE, results='hide'}
co <- system.file("files/STRUCTUREpop_K4-combined.txt",package="pophelper")
al <- system.file("files/STRUCTUREpop_K4-combined-aligned.txt",package="pophelper")
me <- system.file("files/STRUCTUREpop_K4-combined-merged.txt",package="pophelper")

readQ(co)
readQ(al)
readQ(me)

readQ(co,filetype="clumpp")
```

For CLUMPP files containing multiple runs, each run name is suffixed by a -1, -2 etc. `names(readQ(co))`.

## tabulateQ 
The function `tabulateQ()` takes a qlist and produces a table of runs with various parameters. The results can be pointed to a variable for further use.

```{r,echo=TRUE, eval=FALSE, results='hide'}
# basic usage
tr1 <- tabulateQ(qlist=slist)
tabulateQ(tlist)
tabulateQ(alist, writetable=TRUE)

# choose files
# files=choose.files(multi=TRUE)
tabulateQ(qlist=readQ(files))

?tabulateQ
tabulateQ(qlist=NULL, writetable=FALSE, sorttable=TRUE)
# To write results to working directory, set writetable=TRUE
# Result table is sorted by loci, ind and k. To see original order, set sorttable=FALSE
```

For all filetypes, the `tabulateQ()` function returns a table with three columns namely filename, *K* and number of individuals. The table is sorted by ind and *K*.

```{r, echo=TRUE, eval=TRUE, results="asis"}
library(knitr)
kable(head(tabulateQ(tlist)),caption="Table 1: A tabulated table of TESS runs.")
```

For STRUCTURE runs, the `tabulateQ()` function produces additional columns namely number of loci, number of burn-ins, number of replicates (reps), estimated ln probability of data (elpd), mean value of ln likelihood (mvll) and variance of ln likelihood (vll). The table is sorted by loci, ind and *K*. 

```{r, echo=TRUE, eval=TRUE, results="asis"}
library(knitr)
kable(head(tabulateQ(slist)),caption="Table 2: A tabulated table of STRUCTURE runs.")
```

Missing values are given NA. The tabulated output can be written to the working directory as a text file by setting the argument `writetable=T`.

## summariseQ 

The table produced using `tabulateQ()` can be further collapsed by *K* based on the number of runs. The output table from `tabulateQ()` can be passed as input to `summariseQ()`. 

```{r, echo=TRUE, eval=FALSE}
# basic usage
sr1 <- summariseQ(tr1)
summariseQ(tr1,writetable=TRUE)

# another usage
# sr1 <- summariseQ(tabulateQ(qlist=choose.files()))

# view output
head(sr1)
```

For all filetypes the `summariseQ()` function returns 3 columns namely individuals, *K* and the number of runs.

```{r, echo=TRUE, eval=TRUE, results="asis"}
library(knitr)
kable(head(summariseQ(tabulateQ(tlist))),caption="Table 3: A summarised table of TESS runs.")
```

For STRUCTURE runs, the `summariseQ()` function returns additional 5 columns namely loci, Mean estimated ln probability of data, standard deviation of estimated ln probability of data, estimated ln probability of data minus standard deviation and estimated ln probability of data plus standard deviation.

```{r, echo=TRUE, eval=TRUE, results="asis"}
library(knitr)
kable(head(summariseQ(tabulateQ(slist))),caption="Table 4: A summarised table of STRUCTURE runs.")
```

The summarised runs can be written to the working directory as a text file by setting the argument `writetable=T`.

## evannoMethodStructure  

This function is only applicable to STRUCTURE runs.

The Evanno method^2^ is used to estimate the optimal number of *K*. The summarised runs table output from`summariseQ()` function can be input to `evannoMethodStructure()`. The `evannoMethodStructure()` function creates an Evanno derivative plot if suitable conditions are met. A resulting table is also returned. The plot can be written to file using argument `exportplot=T`. The table can be written to file using `writetable=T`.

```{r,echo=TRUE, eval=FALSE, results='hide'}
# basic usage
evannoMethodStructure(data=sr1)

# another usage
em <- evannoMethodStructure(summariseQ(tabulateQ(slist)))

?evannoMethodStructure
evannoMethodStructure(data=NULL, writetable=FALSE, 
exportplot=FALSE, na.rm=TRUE, imgtype="png", height=NA, width=NA, 
res=NA, units=NA)
# to write result to working directory, set writetable=TRUE
# to export the plots to the working directory, set exportplot=TRUE
# to change export image format, set imgtype="png" or imgtype="jpeg" or imgtype="pdf"
# figure arguments can be changed if required such as height, width, res and dimension units

# to export a plot
evannoMethodStructure(data=sr1,exportplot=T)

# do not calculate plot, only return results as table
em <- evannoMethodStructure(data=sr1,exportplot=F)

# to export plot and table
evannoMethodStructure(data=sr1,exportplot=T,writetable=T,na.rm=T)
```

![evanno-method](evanno-plot.png)  
__Fig. 4:__ *Plots produced from the Evanno method.*

The Evanno method results table has 15 columns namely number of loci (loci), number of individuals (ind), *K* value (k), number of runs (runs), Mean estimated ln probability of data (elpdmean), Standard deviation (elpdsd), Estimated ln probability of data minus standard deviation (elpdmin), Estimated ln probability of data plus standard deviation (elpdmax), First derivative (lnk1), Max error of first derivative (lnk1max), Min error of first derivative (lnk1min), Second derivative (lnk2), Max error of second derivative (lnk2max), Min error of second derivative (lnk2min) and deltaK.  

```{r, echo=TRUE, eval=TRUE, results="asis"}
library(knitr)
kable(evannoMethodStructure(summariseQ(tabulateQ(slist))),caption="Table 5: Results of the Evanno method.")
```

The Evanno method can be computed only if these criteria are met: At least 3 values of *K* must be available, values of *K* must be sequential (ie; there must not be missing values of *K*), number of individuals and loci must be same in all runs. If number of repeats for any *K* is less than 2, then results may not be reliable. In case the Evanno method cannot be computed, a plot of ELPD over *K* is produced referred to as the kPlot.  

From the command above, a png file and text file is exported to the working directory. The peak of deltaK __Fig. 4D__ is usually used to estimate the best value of *K*.  

## clumppExport 

When multiple repeats are run for each *K*, the order of clusters may be jumbled for each run. Therefore, when plotting multiple runs within each *K*, the colours cannot be assigned correctly. The software CLUMPP helps to overcome this issue by reordering the clusters correctly. To read more about CLUMPP^4^, see references.  

![clumpp-folder-preview](clumpp-folder.png)  
__Fig. 5:__ *Folders created from clumpp export (left) and the contents of each folder (right).*

The function `clumppExport()` takes a qlist, combines runs by *K* and generates a combined data file and a paramfile in separate directories. The combined file contains the tabular cluster data from all the repeats and runs. The paramfile contains information for the CLUMPP executable. The name for the folder can be changed optionally using the argument `prefix="something"`.  

```{r,echo=TRUE, eval=FALSE}
# basic usage
clumppExport(qlist=slist)

# select files interactively
# clumppExport(qlist=choose.files(multi=TRUE))

?clumppExport
clumppExport(qlist=NULL, prefix=NA, parammode=NA, paramrep=NA)
# export folders are prefixed as pop by default, to change, use prefix="foo"
# To change clumpp algorithm, set parammode=1, parammode=2 or parammode=3. 
# If clumpp is slow, increase parammode
# To change number of clumpp repeats, set paramrep=200, paramrep=500 etc.

# optionally change folder name
clumppExport(qlist=slist,prefix="Set1")
```

The CLUMPP executable needs to be copied and pasted into each of these folder and executed by running it. Alternatively, the CLUMPP executable can now be run automatically by specifying `useexe=T`. This may not work on all OS and versions. Remember to cite CLUMPP^4^ if this option is used.  

```{r,echo=TRUE, eval=FALSE}
# auto execute CLUMPP
clumppExport(qlist=slist, useexe=T)
```

The CLUMPP executable uses the combined file and the param file to generate three output files: aligned file, merged file and misc file. 

![clumpp-folder-results](clumpp-output.png)  
__Fig. 6:__ *Folder showing CLUMPP results: aligned file, merged file and misc file.*

The aligned file contains all the runs as in the combined file after realignment of clusters. In contrast, the merged file contains only one table which merges all the aligned runs to create a consensus run. The merged file makes sense only if all the aligned runs have similar assignments. The merged file is not recommended for downstream use unless you know what you are doing. The miscfile contains run parameters and other details.  

## collectClumppOutput  

The CLUMPP output files are now distributed in multiple folders. The aligned, merged or both files can be copied from multiple folders into a single folder for further analyses using the function `collectClumppOutput()`. The working directory is set suitably before running this function. This function need a `prefix` argument which denotes the prefix used in the previous function or the text before the underscore. For ex. a directory named `pop_K2` has the prefix `pop`.  

```{r,echo=TRUE, eval=FALSE}
# set working directory
setwd(choose.dir())
# collect aligned files. Default prefix is pop
collectClumppOutput()

# working directory can also be set using runsdir argument
collectClumppOutput(runsdir=choose.dir())

# collect both aligned and merged files
collectClumppOutput(filetype="both")

?collectClumppOutput
collectClumppOutput(prefix="pop", filetype="aligned", runsdir=NA, 
+ newdir=NA, quiet=FALSE)

# to change which files are copied, set filetype="aligned", filetype="both" or 
# filetype="merged"
# to change name of new directory, set newdir="somename"

?collectClumppOutput()
```

Collecting the aligned and merged files into a single folder can be helpful in plotting these files. From the command above, both aligned and merged files are copied into a new directory `pop-aligned` within the working directory.  

## plotQ  

The function `plotQ()` is used to create population-level barplots from a qlist. A schematic of the plot parts is shown below.  

![plotq-overview](plotq-overview.png) 
__Fig. 7:__ *An overview of the components of a `plotQ()` figure and the arguments used to modify them.*

### Separate and Joined plots

The `imgoutput` argument is used to indicate if multiple runs must be plotted as separate plots or as a joined plot. When `imgoutput="sep"`, each run file is plotted and exported as separate figures. When `imgoutput="join"`, all selected run files are plotted as a single figure and exported. Default is set as `imgoutput="sep"`.

```{r,echo=TRUE, eval=FALSE}
# plot first run separately
plotQ(qlist=slist[1])

# plot multiple runs separately
plotQ(qlist=slist[1:3])
# same as above
plotQ(qlist=slist[1:3], imgoutput="sep")

# TESS files
plotQ(qlist=readQ(tfiles)[1:3],imgoutput="sep")
# ADMIXTURE files
plotQ(qlist=readQ(afiles)[1:3],imgoutput="sep")
# FASTSTRUCTURE files
plotQ(qlist=readQ(ffiles)[1:3],imgoutput="sep")
# comma-delimited files
plotQ(qlist=readQ(mcfiles)[1:3],imgoutput="sep")
# space-delimited files
plotQ(qlist=readQ(msfiles)[1:3],imgoutput="sep")
# tab-delimited files
plotQ(qlist=readQ(mtfiles)[1:3],imgoutput="sep")

# join files into one figure
plotQ(qlist=readQ(sfiles)[c(1,3)],imgoutput="join")
plotQ(qlist=readQ(tfiles)[1:3],imgoutput="join")
plotQ(qlist=readQ(afiles)[1:3],imgoutput="join")
plotQ(qlist=readQ(ffiles)[1:3],imgoutput="join")
plotQ(qlist=readQ(mcfiles)[1:3],imgoutput="join")
plotQ(qlist=readQ(msfiles)[1:3],imgoutput="join")
plotQ(qlist=readQ(mtfiles)[1:3],imgoutput="join")
```

![plotq-nolab](structure-nolab.png)  
__Fig. 8:__ *(A) Left: Single run plotted separately. (B) Right: Two runs joined together in one image.*

### Strip panel

The panel on the right side of the plot is the strip panel (`sp`). The strip panel can show labels referred to as the strip labels or strip panel labels. The strip panel by default shows the filename and the *K* value. Strip panel label can be changed to show custom labels or the panel can be turned off altogether. If custom labels are provided, they must be equal to the number of runs.

```{r,echo=TRUE, eval=FALSE}
# turn off strip panel
plotQ(qlist=slist[1], sp=F)
# move strip panel to the left
plotQ(qlist=slist[1], sppos="left")
plotQ(qlist=slist[1:3], imgoutput="join", sppos="left")
# custom strip panel label showing filename only
plotQ(qlist=slist[1], splab=names(slist)[1])

# custom strip panel label showing k only
fn1 <- function(x) attr(x,"k")
spnames <- paste0("K=",sapply(slist,fn1))
plotQ(qlist=slist[1], splab=spnames[1])

# two-line strip panel label
plotQ(qlist=slist[1:3], splab=paste0(names(slist)[1:3],"\n",c("run1","run2","run3")))
plotQ(qlist=slist[1:3], imgoutput="join",
         splab=paste0(names(slist)[1:3],"\n",c("run1","run2","run3")))

# change colour of strip label on plot
plotQ(qlist=slist[1], splabcol="blue")
# change size of strip label on plot
plotQ(qlist=slist[1], splabsize=7)
# change font face of strip label on plot
plotQ(qlist=slist[1], splabface="bold")
# hide strip label on plot
plotQ(qlist=slist[1], splabcol="white")
```

### Cluster colours

Each cluster gets a distinct colour. Up to 12 clusters get colours assigned from a pre-defined palette. Clusters >12 get colours derived from the function `rich.colors()`. The colours can also be manually supplied to `clustercol` as a character of R colours or hexadecimal values. The length of colours must be equal to the maximum *K* value in the runs provided.

![cols](cols.png)  
__Fig. 9:__ *(A) Top: Colour palette used when K<=12. (B) Bottom: Colour function used when K>12.*

```{r,echo=TRUE, eval=FALSE}
# change colour of clusters
plotQ(qlist=slist[3:4], imgoutput="join", 
    clustercol=c("coral","steelblue","lightblue","purple","orange"))

plotQ(qlist=slist[16:17], imgoutput="join", 
    clustercol=c("#A6CEE3", "#3F8EAA", "#79C360", "#E52829", "#FDB762","#ED8F47","#9471B4"))

```

### Legend

A legend denoting colours and labels for clusters can be shown on the top of plots by setting `legend=T`.  

```{r,echo=TRUE, eval=FALSE}
# show legend
plotQ(qlist=slist[3], legend=T)
# move to right side
plotQ(qlist=slist[3], legend=T, legendpos="right")
# change legend key size
plotQ(qlist=slist[3], legend=T, legendkeysize=5)
# change legend text size
plotQ(qlist=slist[3], legend=T, legendtextsize=5)
```

 The clusters in qlist are by default named Cluster1, Cluster2 etc. The cluster names can be renamed by providing custom labels to argument `legendlab`. The length of `legendlab` must be equal to the max number of clusters in the selected runs. 

```{r,echo=TRUE, eval=FALSE}
#number of columns or K value in selected runs
sapply(slist[c(1,3)],ncol)
# joined plot with custom legend labels
plotQ(qlist=slist[c(1,3)], imgoutput="join", legend=T, legendlab=c("group1","group2","group3"))
```

![plotq-legend](structure-legend.png)  
__Fig. 10:__ *(A) Left: Default legend when `legend=T`. (B) Right: Joined plot with custom legend labels using `legendlab=c("group1","group2","group3")`.*

### Sort individuals

Individuals in a plot are by default plotted in the order as in the input data. The individuals can be sorted based on the value of any one of the clusters or 'all'. The 'all' option produces a sort similar to that in the software STRUCTURE. Use the name of a cluster in the argument `sortind` like `sortind="Cluster1"` or `sortind="all"`.

```{r,echo=TRUE, eval=FALSE}
# sorted by cluster 1
plotQ(slist[c(1,3)],sortind="Cluster1")
# sorted by cluster 2
plotQ(slist[1],sortind="Cluster2")
# sorted by all
plotQ(slist[c(1,3)],sortind="all")

# sorted by cluster 3
plotQ(tlist[1],sortind="Cluster3") # gives error because this file contains only 2 clusters

# sorted by cluster 1, three files joined plot
plotQ(slist[c(1,3)],sortind="Cluster1",imgoutput="join")
plotQ(slist[c(1,3)],sortind="all",imgoutput="join")
```

![plotq-nolab-sort](structure-nolab-sort.png)  
__Fig. 11:__ *(A) Left: Joined plot sorted by cluster 1. (B) Right: Joined plot sorted by 'all'.*

### Group labels

One or more sets of group labels can be added to the bottom of barplots by providing a character vector of labels. The length of each vector must be equal to the number of individuals. The vectors must be constructed as a named list. In this demonstration, we will use the labels in the `pophelper` library.  

```{r, echo=TRUE, eval=FALSE}
# read labels for STRUCTURE runs
grp1 <- read.delim(system.file("files/structuregrplabels.txt", package="pophelper"), header=F,stringsAsFactors=F)
head(grp1$V1)
# length of labels equal to number of individuals?
length(grp1$V1)
# check if labels are a character data type
is.character(grp1$V1)
```

Make sure that the labels are character datatype. When reading from a text file, use `stringsAsFactors=F` to ensure that each column in the dataframe is a character and not a factor.  

Read more labels.  
```{r, echo=TRUE, eval=FALSE}
# group labels for TESS runs
tgrp <- read.delim(system.file("files/tessgrplabels.txt", package="pophelper"), header=F,stringsAsFactors=F)
head(tgrp$V1)
# group labels for ADMIXTURE runs
agrp <- read.delim(system.file("files/admixturegrplabels.txt", package="pophelper"), header=F,stringsAsFactors=F)
head(agrp$V1)
# group labels for FASTSTRUCTURE runs
fgrp <- read.delim(system.file("files/faststructuregrplabels.txt", package="pophelper"), header=F,stringsAsFactors=F)
head(fgrp$V1)

```

Now we provide the group labels as a list. The 'lab1' is the title of the group labels.  

```{r, echo=TRUE, eval=FALSE}
plotQ(qlist=slist[1],grplab=list("lab1"=grp1$V1))
```

![plotq-incorrect](structure-unequal-spacing.png)  
__Fig. 12:__ *STRUCTURE barplot showing incorrect alignment of labels and clusters.*

In the above example, note how the group labels do not align with the barplot panels. This is because the strip panel has a label of 2 lines and the group label title has one line. This can be corrected by adding an extra line to grp label title or providing custom one-line strip panel label.

```{r, echo=TRUE, eval=FALSE}
#correctly align plot panel and label panel
plotQ(qlist=slist[1],grplab=list("lab1\n"=grp1$V1))
plotQ(qlist=slist[1],grplab=list("lab1"=grp1$V1),splab="K=2")
# turn off strip panel
plotQ(qlist=slist[1],grplab=list("lab1"=grp1$V1),sp=F)
```

![plotq-corrected](structure-corrected.png)  
__Fig. 13:__ *STRUCTURE barplots showing corrected alignment of labels and clusters.*

```{r, echo=TRUE, eval=FALSE}
# plot separately with labels
plotQ(slist[1],grplab=list("lab1\n"=grp1$V1))
plotQ(tlist[1],grplab=list("lab1\n"=tgrp$V1))

# plot multiple files with a common label
plotQ(slist[c(1,3)], imgoutput="join", grplab=list("lab1\n"=grp1$V1))
plotQ(tlist[1:2], imgoutput="join", grplab=list("lab1\n"=tgrp$V1))
plotQ(alist[1:2], imgoutput="join", grplab=list("lab1\n"=agrp$V1))
plotQ(flist[1:2], imgoutput="join", grplab=list("lab1\n"=fgrp$V1))
plotQ(mslist[1:2], imgoutput="join", grplab=list("lab1\n"=tgrp$V1))
plotQ(mtlist[1:2], imgoutput="join", grplab=list("lab1\n"=tgrp$V1))
plotQ(mclist[1:2], imgoutput="join", grplab=list("lab1\n"=tgrp$V1))

# adjust label angle and justification
plotQ(slist[1], grplab=list("lab1\n"=grp1$V1), labangle=90, labjust=0.5)
# adjust labpanelheight to fit labels
plotQ(slist[1], grplab=list("lab1\n"=grp1$V1), labangle=90, labjust=0.5, labpanelheight=0.8)

# when labpanelheight is high enough, use labpos to move labels vertically
plotQ(slist[1], grplab=list("lab1\n"=grp1$V1), labpanelheight=0.9, labpos=0.5)
plotQ(slist[1], grplab=list("lab1\n"=grp1$V1), labpanelheight=0.9, labpos=0.3)

# adjust label colour
plotQ(slist[1] ,grplab=list("lab1\n"=grp1$V1), labcol="green")

# adjust marker points
plotQ(slist[1], grplab=list("lab1\n"=grp1$V1), pointtype=20, pointsize=1.2)
plotQ(slist[1], grplab=list("lab1\n"=grp1$V1), pointtype=21, pointcol="green", pointbgcol="red")
plotQ(slist[1], grplab=list("lab1\n"=grp1$V1), pointtype="$", pointcol="green", pointsize=2)

# adjust marker line
plotQ(slist[1], grplab=list("lab1\n"=grp1$V1), linethick=0.5, linecol="steelblue")
plotQ(slist[1], grplab=list("lab1\n"=grp1$V1), linecol="steelblue", linetype=3, linethick=0.2)

# 2 line label and adjust label text position
lab1 <- paste(grp1$V1,c(rep("Group 1",107), rep("Group 2",42)),sep="\n")
plotQ(slist[c(1,3,5)], imgoutput="join", grplab=list("lab1\n"=lab1),
         labpanelheight=0.8, labpos=0.3)
```

![plotq-lab](structure-lab.png)  
__Fig. 14:__ *(A) Left: Single run plotted separately with group labels. (B) Right: Two runs joined together in one image with group labels.*

More than one set of group label sets can be be added to the plot by providing multiple vectors of labels.

```{r, echo=TRUE, eval=FALSE}
# read another grp label set
grp2 <- read.delim(system.file("files/structuregrplabels2.txt", package="pophelper"), header=F,stringsAsFactors=F)

plotQ(slist[1],grplab=list("lab1\n"=grp1$V1,"lab2\n"=grp2$V1))
plotQ(slist[1],grplab=list("lab1\n"=grp1$V1,"lab2\n"=grp2$V1), sp=F)
```

![plotq-dual-lab](structure-dual-labels.png) 
__Fig. 15:__ *(A) Left: Single run plotted with two sets of group labels. (B) Right: Two runs joined together along with two sets of group labels and strip panel turned off (`sp=F`).*

Multiple plot argument adjustments to obtain a new label style.

```{r, echo=TRUE, eval=FALSE}
plotQ(slist[1] ,grplab=list("lab1\n"=grp1$V1,"lab2\n"=grp2$V1), linethick=2.8, linealpha=0.2, pointcol="white", pointsize=2, labpos=0.5, linepos=0.5, labpanelheight=0.75)
```

![plotq-newlook](structure-newlook.png)  
__Fig. 16:__ *Group labels in a different style*.

### Divider line

The white dotted line dividing the groups on the panels is called the divider line. By default, the divider line is drawn between groups in the first group label set (See figures above). This can be changed by providing titles of group labels to the argument `divgrp`.

```{r, echo=TRUE, eval=FALSE}
# use second group label set as dividers
plotQ(slist[1],grplab=list("lab1\n"=grp1$V1,"lab2\n"=grp2$V1),divgrp="lab2\n")
# use both group label sets as dividers
plotQ(slist[1],grplab=list("lab1\n"=grp1$V1,"lab2\n"=grp2$V1),divgrp=c("lab1\n","lab2\n"))
```

![plotq-divgrp](structure-divgrp.png)  
__Fig. 17:__ *(A) Left: Divider lines for the second group label set. (B) Right: Divider lines for both group label sets.*

The divider liness can also be modified and adjusted.

```{r, echo=TRUE, eval=FALSE}
# change div colour, type and thickness
plotQ(slist[1],grplab=list("lab1\n"=grp1$V1),divcol="black",divtype=1,divthick=1)
```

### Sorting with group labels

Individuals can be sorted while using group labels. The individuals are sorted within their groups. Only one group label set can be used when sorting individuals.

```{r, echo=TRUE, eval=FALSE}
# with grp labels, sort individuals
plotQ(slist[1],grplab=list("lab1\n"=grp1$V1),sortind="Cluster1")
plotQ(slist[1],grplab=list("lab1\n"=grp1$V1),sortind="all")

# with grp labels, sort individuals, multiple files single
plotQ(slist[1:3],grplab=list("lab1\n"=grp1$V1),sortind="Cluster1")
plotQ(slist[1:3],grplab=list("lab1\n"=grp1$V1),sortind="all")

# with grp labels, sort individuals, multiple files joined
plotQ(slist[c(1,3)],grplab=list("lab1\n"=grp1$V1),sortind="Cluster2",imgoutput="join")
plotQ(slist[c(1,3)],grplab=list("lab1\n"=grp1$V1),sortind="all",imgoutput="join")
```

![plotq-lab-sort](structure-lab-sort.png)  
__Fig. 18:__ *(A) Left: Joined plot with group labels sorted by cluster 1. (B) Right: Joined plot with group labels sorted by 'all'.*

### Subset/reorder groups

When using group labels, the plot can be subsetted or reordered based on group labels. This applies only when one group label set is in use.

```{r, echo=TRUE, eval=FALSE}
# subsetting groups
plotQ(slist[1],grplab=list("lab1\n"=grp1$V1),subsetgrp="Pop A")
# change order of groups
plotQ(slist[1],grplab=list("lab1\n"=grp1$V1),subsetgrp=c("Pop B","Pop A"))

# subsetting group and sorting individuals
plotQ(slist[1],grplab=list("lab1\n"=grp1$V1),subsetgrp="Pop A",sortind="Cluster1")
plotQ(slist[1],grplab=list("lab1\n"=grp1$V1),subsetgrp="Pop A",sortind="all")

# change order of groups and sorting individuals
plotQ(slist[1],grplab=list("lab1\n"=grp1$V1),subsetgrp=c("Pop B","Pop A"),sortind="Cluster1")
plotQ(slist[c(1,3)],grplab=list("lab1\n"=grp1$V1),subsetgrp=c("Pop B","Pop A"),sortind="all",imgoutput="join")
```

![plotq-lab-subsetreorder](structure-lab-subsetreorder.png)  
__Fig. 19:__ *(A) Left: Single run with with subsetted group. (B) Middle: Single run with reordered groups. (C) Right: Joined plot with reordered groups.*

In similar manner, the `plotsRuns` function can be used to plot from COMBINED, ALIGNED or MERGED files.

```{r,echo=TRUE, eval=FALSE}
# select files from package
co <- system.file("files/STRUCTUREpop_K4-combined.txt",package="pophelper")
al <- system.file("files/STRUCTUREpop_K4-combined-aligned.txt",package="pophelper")
me <- system.file("files/STRUCTUREpop_K4-combined-merged.txt",package="pophelper")

# all runs within the file are plotted
# combined
plotQ(readQ(co),imgoutput="join")
# aligned
plotQ(readQ(al),imgoutput="join")
# merged only one run
plotQ(readQ(me))

# plot with labels
plotQ(readQ(co),grplab=list("lab1\n"=grp1$V1))
plotQ(readQ(al),imgoutput="join",grplab=list("lab1\n"=grp1$V1))
```

![plotq-tab-nolab](structure-tab-nolab.png)  
__Fig. 20:__ *(A) Left: Combined file (Three STRUCTURE runs for K=4). (B) Middle: Aligned file (Three STRUCTURE runs for K=4 aligned using CLUMPP). (C) Right: Merged file (Three runs for K=4 merged into one table/figure using CLUMPP)*  

### Group mean  

An additional feature is the ability to plot mean values (`grpmean=T`) by group when group labels are in use. `grpmean` cannot be used when more than one set of group label sets is in use.

```{r,echo=TRUE, eval=FALSE}
# group mean
plotQ(slist[4],grplab=list("lab1\n"=grp1$V1),grpmean=T)
plotQ(readQ(al),imgoutput="join",grplab=list("lab1\n"=grp1$V1),grpmean=T)
```

![plotq-structure-lab-grpmean](structure-lab-grpmean.png)  
__Fig. 21:__ *(A) Left: STRUCTURE file showing group mean values. (B) Right: Aligned CLUMPP file showing group mean.*

The height, width, resolution and figure format can be changed as shown below. The height specifies the height of one panel if the plot is joined. The function multiplies the height values by the number of panels.

```{r,echo=TRUE, eval=FALSE}
slist <- readQ(sfiles)

# change height and width of figure
plotQ(qlist=slist[1], imgoutput="sep", height=1.5, width=8)
plotQ(qlist=slist[1:3], imgoutput="join", height=1.5, width=8)

# change resolution
plotQ(qlist=slist[1],dpi=600)
# change export figure format
plotQ(qlist=slist[1], imgtype="jpeg")
plotQ(qlist=slist[1], imgtype="pdf")
```

`plotQ()` function has numerous arguments to tweak the plot as required. See `?plotQ` for more arguments and descriptions.

## plotQMultiline  

The `plotQMultiline` function is also used to plot barplots from a qlist. The barplots are plotted in multiple rows to enable easier identification of individuals. The figure is produced as A4 size by default. The number of samples per line `spl` and the number of lines per page `lpp` is automatically calculated but it can also be specified manually.

```{r,echo=TRUE, eval=FALSE}
# basic usage
plotQMultiline(slist[1])
plotQMultiline(tlist[1])
plotQMultiline(alist[1])
plotQMultiline(flist[1])
plotQMultiline(mclist[1])
plotQMultiline(mslist[1])
plotQMultiline(mtlist[1])

# manually modifying samples per line and lines per page
plotQMultiline(slist[1],spl=75,lpp=10)
plotQMultiline(slist[1],spl=149,lpp=9)
# with TESS runs
plotQMultiline(tlist[1],spl=75,lpp=10)
# with TESS runs
plotQMultiline(alist[1],spl=168,lpp=10)

# works with combined, aligned or merged files
plotQMultiline(readQ(co),spl=75,lpp=10)

# change bar width and turn off labels
plotQMultiline(readQ(al), barwidth=1, indlabs=F)
# yaxis labels and ticks and modified height and width
plotQMultiline(readQ(al),spl=75,lpp=2,indlabs=T,yaxislabs=T,ticks=T,height=5,width=20)
# modified spl
plotQMultiline(readQ(me),spl=38,height=8,width=14)
```

Similar to `plotQ()`, individuals can be sorted by any one cluster or 'all'. The 'all' option takes all clusters into account while sorting and produces a result similar to that produced in the STRUCTURE software 'Sort by Q' option.  

```{r,echo=TRUE, eval=FALSE}
plotQMultiline(slist[1],sortind="Cluster1")
plotQMultiline(slist[1],sortind="all")
plotQMultiline(slist[1],spl=75,lpp=10,sortind="Cluster1")
plotQMultiline(slist[1],spl=75,lpp=10,sortind="all")
```

![plotqmultiline](plotqmultiline.png)  
__Fig. 21:__ *Left: Default output from `plotQMultiline`. Middle Left: Modified output with custom `spl` and `lpp`. Middle Right: Sorted by Cluster1. Right: Sorted by 'all'.*

By default, the individuals are labelled numerically (1,2,3..). Individual labels from the rownames of input data can be used by specifying `useindlab=T`. The individual labels can be turned off by using `indlab=F`.

```{r,echo=TRUE, eval=FALSE}
# get a qlist
list1 <- slist[1]

#read some individual labels
inds <- read.delim(system.file("files/structureindlabels.txt",package="pophelper"),header=FALSE,stringsAsFactors=FALSE)

# add labels as rownames to qlist
rownames(list1[[1]]) <- inds$V1

# add ind labels.
plotQMultiline(list1,useindlab=T)
# turn off ind labels
plotQMultiline(list1,indlab=F)

#sort
plotQMultiline(list1,useindlab=T,sortind="all")
plotQMultiline(list1,useindlab=T,sortind="Cluster1")

# long ind name
longlabs <- paste0("this_is_a_real_long_label_",inds$V1)
rownames(list1[[1]]) <- longlabs
plotQMultiline(list1,useindlab=T)
plotQMultiline(list1,useindlab=T,spl=75,lpp=4)
plotQMultiline(list1,useindlab=T,spl=75,lpp=4)

# change cluster colours
plotQMultiline(list1,useindlab=T,clustercol=c("steelblue","coral"))
# change bar width
plotQMultiline(list1,useindlab=T,barwidth=1,spl=149,lpp=1,labsize=3,height=5)
```

![plotqmultiline-colours](plotqmultiline-colours.png)  
__Fig. 22:__ *Multiline plots with (left) standard colours, (middle) `rich.colors()` from `gplots` package and (right) `brewer.pal(8,"Spectral")` from `RColorBrewer` package.*

Note that this function can be slow and takes several minutes to run depending on number of individuals and number of files selected.

## distructExport

DISTRUCT^7^ is one of the original programs written to generate assignment barplots from a q-matrix. This function generates all output files necessary to run DISTRUCT from a qlist. A directory labelled 'filename-distruct' is created for each input file. Each directory contains the 'filename-indq.txt', 'filename-grpq.txt', 'filename-colours.txt' and 'drawparams'. If grplab is in use, then 'filename-grplabbottom.txt' and/or 'filename-grplabtop.txt' are also created. The DISTRUCT executable can be run in this directory to create a 'filename.ps' postcript vector file. Using `useexe=T` will run the DISTRUCT executable automatically. Remember to cite DISTRUCT^7^ if this option is used. The 'filename.ps' file can be imported into a vector image editing software or seen using a viewer.

```{r,echo=TRUE, eval=FALSE}
# basic usage
distructExport(slist[1])
distructExport(slist[1],quiet=T)
# with bottom labels
distructExport(qlist=slist[1],grplabbottom=grp1$V1)
# with group mean
distructExport(slist[1],grpmean=T)
# grayscale colours
distructExport(slist[1],grayscale=T)
# automatically run distruct executable
distructExport(slist[1],useexe=T)

# TESS files
distructExport(tlist[2])
# ADMIXTURE files, adjust if plot does not fit on canvas
distructExport(alist[3],indwidth=0.36,xorigin=15)
# CLUMPP files
distructExport(readQ(co))
distructExport(readQ(al))
distructExport(readQ(me))
```

![distructexport](destruct-structure.png)  
__Fig. 23:__ *Left: DISTRUCT plot with `grpmean=F`. Middle: DISTRUCT plot with `grpmean=T`. Right: DISTRUCT plot with `grayscale=T`.*  

The `useexe=T` argument may not work on all OS and systems.  

## analyseQ  

This is a wrapper function for easily performing several `pophelper` functions in one function. Input files can be STRUCTURE, TESS or BASIC run files. The `analyseQ()` function performs a tabulation of runs, summarising of runs, perform Evanno method (for STRUCTURE runs only), exports clumpp output and generates barplots.

```{r,echo=TRUE, eval=FALSE}
# basic usage
analyseQ(choose.files())
analyseQ(files=slist)
analyseQ(files=tlist)
analyseQ(files=alist)
```

----

# Working code

Here is a list of all functions in a order typical of workflow.

## Structure  

```{r,echo=TRUE, eval=FALSE}
# choose files
sfiles <- choose.files(multi=TRUE)
# STRUCTURE runs to qlist
slist <- readQ(sfiles,filetype="structure")
# tabulate runs
df1 <- tabulateQ(slist)
# summarise runs
df2 <- summariseQ(df1)
# Evanno method
evannoMethodStructure(df2,exportplot=T)
# clumpp export
clumppExport(slist)
# collect clumpp output
collectClumppOutput(prefix="pop",filetype="aligned")
# plot runs
plotQ(slist)
plotQ(slist,imgoutput="join")
# plot multiline
plotQMultiline(slist[1])
plotQMultiline(slist[1],spl=70,lpp=10)

# or all together
analyseQ(sfiles)
```

## Tess  

```{r,echo=TRUE, eval=FALSE}
# collect TESS output
collectRunsTess(runsdir=choose.dir())
# choose files
tfiles <- choose.files(multi=TRUE)
# TESS runs to qlist
tlist <- readQ(tfiles,filetype="tess")
# tabulate runs
df1 <- tabulateQ(tlist)
# summarisee runs
df2 <- summariseQ(df1)
# clumpp export
clumppExport(tlist)
# collect clumpp output
collectClumppOutput(prefix="pop",filetype="aligned")
# plot runs
plotQ(tlist)
plotQ(tlist,imgoutput="join")
# plot multiline
plotQMultiline(tlist[1])
plotQMultiline(tlist[1],spl=70,lpp=10)

# or all together
analyseQ(tfiles)
```

## Basic  
Run files such as Admixture, fastStructure or any delimited numeric text files. 

```{r,echo=TRUE, eval=FALSE}
# choose files
afiles <- choose.files(multi=TRUE)
# delimited-text-runs to qlist
alist <- readQ(afiles,filetype="basic")
# tabulate runs
df1 <- tabulateQ(alist)
# summarise runs
df2 <- summariseQ(df1)
# clumpp export
clumppExport(alist)
# collect clumpp output
collectClumppOutput(prefix="pop",filetype="aligned")
# plot runs
plotQ(files=alist)
plotQ(files=alist,imgoutput="join")
# plot multiline
plotQMultiline(alist[1])
plotQMultiline(alist[1],spl=70,lpp=10)

# or all together
analyseQ(afiles)
```

Many of the functionalities in this package have been implented in the online tool [Pophelper web app](https://www.pophelper.com). For those who prefer a graphical web interface, this may be useful.  

----

# References

1. [Alexander D.H., Novembre, J. and Lange K. (2009). Fast model-based estimation of ancestry in unrelated individuals. Genome Research, 19:1655-1664](http://genome.cshlp.org/content/19/9/1655.long)  

2. [Evanno G., Regnaut S., and Goudet J. (2005). Detecting the number of clusters of individuals using the software STRUCTURE: a simulation study. Molecular ecology, 14(8), 2611-2620](http://onlinelibrary.wiley.com/doi/10.1111/j.1365-294X.2005.02553.x/abstract)  

3. [Francois O., and Durand E. (2010). Spatially explicit Bayesian clustering models in population genetics. Molecular Ecology Resources, 10(5), 773-784](http://onlinelibrary.wiley.com/doi/10.1111/j.1755-0998.2010.02868.x/abstract)  

4. [Jakobsson M., and Rosenberg N. A. (2007). CLUMPP: a cluster matching and permutation program for dealing with label switching and multimodality in analysis of population structure. Bioinformatics, 23(14), 1801-1806](http://bioinformatics.oxfordjournals.org/content/23/14/1801.short)

5. [Pritchard J. K., Stephens M., & Donnelly P. (2000). Inference of population structure using multilocus genotype data. Genetics, 155(2), 945-959](http://www.genetics.org/content/155/2/945.short)  

6. [Raj A., Stephens M., Pritchard J.K. (2014). fastSTRUCTURE: variational inference of population structure in large SNP data sets. Genetics 197, 573-589](http://www.genetics.org/content/early/2014/04/14/genetics.114.164350)  

7. [Rosenberg, Noah A. "DISTRUCT: a program for the graphical display of population structure." Molecular Ecology Notes 4.1 (2004): 137-138.](http://onlinelibrary.wiley.com/doi/10.1046/j.1471-8286.2003.00566.x/abstract)  

----

# Useful Links

* [STRUCTURE program](http://pritchardlab.stanford.edu/structure.html)  
* [TESS program](http://membres-timc.imag.fr/Olivier.Francois/tess.html)  
* [ADMIXTURE program](https://www.genetics.ucla.edu/software/admixture/)  
* [fastSTRUCTURE program](https://rajanil.github.io/fastStructure/)  
* [CLUMPP program](http://www.stanford.edu/group/rosenberglab/clumpp.html)  
* [Structure Harvester](http://taylor0.biology.ucla.edu/structureHarvester)  
* [Adegenet R package](http://adegenet.r-forge.r-project.org/)  
* [Distruct program](https://web.stanford.edu/group/rosenberglab/distruct.html)

----

# Compatibility

`pophelper 2.0.0` has been tested on the following systems:

+ Windows 10 64bit, R 3.3.2

```{coffee,echo=TRUE, eval=FALSE}
R version 3.3.2 (2016-10-31)
Platform: x86_64-w64-mingw32/x64 (64-bit)
Running under: Windows >= 8 x64 (build 9200)

locale:
[1] LC_COLLATE=English_United Kingdom.1252 
[2] LC_CTYPE=English_United Kingdom.1252   
[3] LC_MONETARY=English_United Kingdom.1252
[4] LC_NUMERIC=C                           
[5] LC_TIME=English_United Kingdom.1252    

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] testthat_1.0.2  pophelper_2.0.0 ggplot2_2.2.0   Cairo_1.5-9    

loaded via a namespace (and not attached):
 [1] Rcpp_0.12.8      tidyr_0.6.0      dplyr_0.5.0      crayon_1.3.2    
 [5] assertthat_0.1   R6_2.2.0         grid_3.3.2       plyr_1.8.4      
 [9] DBI_0.5-1        gtable_0.2.0     magrittr_1.5     scales_0.4.1    
[13] stringi_1.1.2    reshape2_1.4.2   lazyeval_0.2.0   labeling_0.3    
[17] tools_3.3.2      stringr_1.1.0    munsell_0.4.3    colorspace_1.3-1
[21] gridExtra_2.2.1  tibble_1.2 
```

+ Windows 10 64bit, R 3.3.1

```{coffee,echo=TRUE, eval=FALSE}
R version 3.3.1 (2016-06-21)
Platform: x86_64-w64-mingw32/x64 (64-bit)
Running under: Windows >= 8 x64 (build 9200)

locale:
[1] LC_COLLATE=English_United Kingdom.1252 
[2] LC_CTYPE=English_United Kingdom.1252   
[3] LC_MONETARY=English_United Kingdom.1252
[4] LC_NUMERIC=C                           
[5] LC_TIME=English_United Kingdom.1252    

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] pophelper_2.0.0 ggplot2_2.2.0   Cairo_1.5-9    

loaded via a namespace (and not attached):
 [1] colorspace_1.2-7 scales_0.4.1     magrittr_1.5     assertthat_0.1  
 [5] lazyeval_0.2.0   plyr_1.8.4       tools_3.3.1      gtable_0.2.0    
 [9] tibble_1.2       gridExtra_2.2.1  Rcpp_0.12.7      grid_3.3.1      
[13] tidyr_0.6.0      munsell_0.4.3   
```

+ Windows 7 64bit, R 3.3.0

```{coffee,echo=TRUE, eval=FALSE}
R version 3.3.0 (2016-05-03)
Platform: x86_64-w64-mingw32/x64 (64-bit)
Running under: Windows 7 x64 (build 7601) Service Pack 1

locale:
[1] LC_COLLATE=English_United Kingdom.1252  LC_CTYPE=English_United Kingdom.1252   
[3] LC_MONETARY=English_United Kingdom.1252 LC_NUMERIC=C                           
[5] LC_TIME=English_United Kingdom.1252    

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] pophelper_2.0.0 Cairo_1.5-9     ggplot2_2.2.0  

loaded via a namespace (and not attached):
 [1] colorspace_1.2-7 scales_0.4.1     magrittr_1.5     assertthat_0.1  
 [5] lazyeval_0.2.0   plyr_1.8.4       tools_3.3.0      gtable_0.2.0    
 [9] tibble_1.2       gridExtra_2.2.1  Rcpp_0.12.7      grid_3.3.0      
[13] tidyr_0.6.0      munsell_0.4.3  
```

+ Windows 7 64bit, R 3.3.2

DISTRUCT executable worked but unstable.

```{coffee,echo=TRUE, eval=FALSE}
R version 3.3.2 (2016-10-31)
Platform: x86_64-w64-mingw32/x64 (64-bit)
Running under: Windows 7 x64 (build 7601) Service Pack 1

locale:
[1] LC_COLLATE=English_United Kingdom.1252  LC_CTYPE=English_United Kingdom.1252   
[3] LC_MONETARY=English_United Kingdom.1252 LC_NUMERIC=C                           
[5] LC_TIME=English_United Kingdom.1252    

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] pophelper_2.0.0 ggplot2_2.2.0   Cairo_1.5-9     devtools_1.12.0

loaded via a namespace (and not attached):
 [1] Rcpp_0.12.8      tidyr_0.6.0      assertthat_0.1   digest_0.6.10   
 [5] withr_1.0.2      plyr_1.8.4       grid_3.3.2       R6_2.2.0        
 [9] gtable_0.2.0     magrittr_1.5     git2r_0.16.0     scales_0.4.1    
[13] httr_1.2.1       lazyeval_0.2.0   curl_2.3         tools_3.3.2     
[17] munsell_0.4.3    colorspace_1.3-1 memoise_1.0.0    knitr_1.15.1    
[21] gridExtra_2.2.1  tibble_1.2 
```

+ Ubuntu Linux 16.04.1 LTS 64bit, R 3.3.2

DISTRUCT executable does not work.

```{coffee,echo=TRUE, eval=FALSE}
R version 3.3.2 (2016-10-31)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 16.04.1 LTS

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
 [3] LC_TIME=en_GB.UTF-8        LC_COLLATE=en_US.UTF-8    
 [5] LC_MONETARY=en_GB.UTF-8    LC_MESSAGES=en_US.UTF-8   
 [7] LC_PAPER=en_GB.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_GB.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods  
[7] base     

other attached packages:
[1] pophelper_2.0.0 ggplot2_2.2.0   Cairo_1.5-9    

loaded via a namespace (and not attached):
 [1] colorspace_1.2-6 scales_0.4.1     magrittr_1.5     assertthat_0.1  
 [5] lazyeval_0.2.0   plyr_1.8.4       tools_3.3.2      gtable_0.2.0    
 [9] tibble_1.1       gridExtra_2.2.1  Rcpp_0.12.6      grid_3.3.2      
[13] tidyr_0.5.1      munsell_0.4.3 
```

+ Scientific Linux 6.8 (Carbon) 64bit, R 3.3.1

```{coffee,echo=TRUE, eval=FALSE}
R version 3.3.1 (2016-06-21)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Scientific Linux release 6.8 (Carbon)

locale:
 [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C
 [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8
 [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8
 [7] LC_PAPER=en_US.UTF-8       LC_NAME=C
 [9] LC_ADDRESS=C               LC_TELEPHONE=C
[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base

other attached packages:
[1] pophelper_2.0.0 ggplot2_2.2.0   Cairo_1.5-9

loaded via a namespace (and not attached):
 [1] colorspace_1.2-6 scales_0.4.1     magrittr_1.5     assertthat_0.1
 [5] lazyeval_0.2.0   plyr_1.8.4       tools_3.3.1      gtable_0.2.0
 [9] tibble_1.1       gridExtra_2.2.1  Rcpp_0.12.6      grid_3.3.1
[13] tidyr_0.6.0      munsell_0.4.3
```

---

# Disclaimer

The `pophelper` R package is offered free and without warranty of any kind, either expressed or implied. I will not be held liable to you for any damage arising out of the use, modification or inability to use this program. `pophelper` R package can be used, redistributed and/or modified freely for non-commercial purposes subject to the original source being properly cited. Licensed under GPL-3. Please make sure you verify all your results.  

----

# Contact

If you have any comments, suggestions or issues, report on the [Github issues page](https://github.com/royfrancis/pophelper/issues).  
  
__End of Document.__  
